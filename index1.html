<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D Heart with Slow Orbiting Hearts</title>
<style>
  body { margin: 0; background: black; overflow: hidden; }
  canvas { display: block; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script>
let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
let renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

function heart3D(numPoints, scale=1) {
  let points = [];
  while (points.length < numPoints) {
    let x = (Math.random()*2 - 1) * 1.5;
    let y = (Math.random()*2 - 1) * 1.5;
    let z = (Math.random()*2 - 1) * 1.5;
    let f = Math.pow(x*x + (9/4)*y*y + z*z - 1, 3) - x*x*z*z*z - (9/80)*y*y*z*z*z;
    if (f <= 0) points.push(x*20*scale, y*20*scale, z*20*scale);
  }
  return new Float32Array(points);
}

// === Trái tim chính ===
let heartGeo = new THREE.BufferGeometry();
heartGeo.setAttribute("position", new THREE.BufferAttribute(heart3D(40000, 1.2), 3));
let heartMat = new THREE.PointsMaterial({ size: 0.3, color: 0xff3366, transparent: true, opacity: 0.9 });
let heart = new THREE.Points(heartGeo, heartMat);
let heartGroup = new THREE.Group();
heart.rotation.x = -Math.PI / 2;
heartGroup.add(heart);
scene.add(heartGroup);

// === Trái tim trắng lớn ===
let whiteHeartGeo = new THREE.BufferGeometry();
whiteHeartGeo.setAttribute("position", new THREE.BufferAttribute(heart3D(20000, 2.5), 3));
let whiteHeartMat = new THREE.PointsMaterial({ size: 0.6, color: 0xffffff, transparent: true, opacity: 0.85 });
let whiteHeart = new THREE.Points(whiteHeartGeo, whiteHeartMat);
let whiteHeartGroup = new THREE.Group();
whiteHeart.rotation.x = -Math.PI / 2;
whiteHeartGroup.add(whiteHeart);
scene.add(whiteHeartGroup);

// === Hạt phân tán ===
let particleCount = 6000;
let pGeo = new THREE.BufferGeometry();
let pPos = new Float32Array(particleCount*3);
let colors = new Float32Array(particleCount*3);
let velocities = [];
let brightness = [];

for (let i=0;i<particleCount;i++){
  pPos[i*3]=0; pPos[i*3+1]=0; pPos[i*3+2]=0;
  velocities.push({x:(Math.random()-0.5)*0.5, y:(Math.random()-0.5)*0.5, z:(Math.random()-0.5)*0.5});
  colors[i*3]=Math.random(); colors[i*3+1]=Math.random(); colors[i*3+2]=Math.random();
  brightness.push(Math.random() * Math.PI * 2);
}
pGeo.setAttribute("position", new THREE.BufferAttribute(pPos,3));
pGeo.setAttribute("color", new THREE.BufferAttribute(colors, 3));
let pMat = new THREE.PointsMaterial({ size:0.5, vertexColors:true, transparent:true, opacity:1.0 });
let particles = new THREE.Points(pGeo, pMat);
scene.add(particles);

// === Trái tim nhỏ quay quanh chậm hơn ===
let smallHeartGroups = [];
let smallHeartCount = 10;
for (let i=0;i<smallHeartCount;i++){
  let geo = new THREE.BufferGeometry();
  geo.setAttribute("position", new THREE.BufferAttribute(heart3D(2000, 0.4), 3));
  let mat = new THREE.PointsMaterial({ size: 0.2, color: 0xff99cc, transparent: true, opacity: 0.8 });
  let smallHeart = new THREE.Points(geo, mat);
  smallHeart.rotation.x = -Math.PI / 2;
  let group = new THREE.Group();
  group.add(smallHeart);
  let radius = 60 + i*15;
  group.userData = {
    angle: Math.random()*Math.PI*2,
    speed: (0.002 + Math.random()*0.002), // Giảm tốc độ quay
    radius: radius
  };
  group.position.x = radius * Math.cos(group.userData.angle);
  group.position.z = radius * Math.sin(group.userData.angle);
  smallHeartGroups.push(group);
  scene.add(group);
}

// === Hạt bắn tia sáng ===
let sparkCount = 500;
let sparkGeo = new THREE.BufferGeometry();
let sparkPos = new Float32Array(sparkCount*3);
let sparkVel = [];
let sparkColors = new Float32Array(sparkCount*3);

for (let i=0;i<sparkCount;i++){
  sparkPos[i*3]=0; sparkPos[i*3+1]=0; sparkPos[i*3+2]=0;
  let speed = Math.random()*2+0.5;
  let theta = Math.random()*Math.PI*2;
  let phi = Math.random()*Math.PI;
  sparkVel.push({
    x: speed * Math.sin(phi) * Math.cos(theta),
    y: speed * Math.sin(phi) * Math.sin(theta),
    z: speed * Math.cos(phi)
  });
  sparkColors[i*3]=1; sparkColors[i*3+1]=0.5+Math.random()*0.5; sparkColors[i*3+2]=Math.random();
}
sparkGeo.setAttribute("position", new THREE.BufferAttribute(sparkPos,3));
sparkGeo.setAttribute("color", new THREE.BufferAttribute(sparkColors,3));
let sparkMat = new THREE.PointsMaterial({ size:0.6, vertexColors:true, transparent:true, opacity:1.0 });
let sparks = new THREE.Points(sparkGeo, sparkMat);
scene.add(sparks);

camera.position.z = 200;
camera.position.y = 0;

let time = 0;
function animate(){
  requestAnimationFrame(animate);
  time += 0.02;

  heartGroup.rotation.y -= 0.002;
  whiteHeart.material.opacity = 0.85 + 0.15 * Math.cos(time*2);

  let arr = pGeo.attributes.position.array;
  for (let i=0;i<particleCount;i++){
    arr[i*3]   += velocities[i].x;
    arr[i*3+1] += velocities[i].y;
    arr[i*3+2] += velocities[i].z;
    brightness[i] += 0.05;
  }
  let b = 0.9 + 0.2 * Math.sin(time*3);
  pMat.opacity = b;
  pGeo.attributes.position.needsUpdate = true;

  for (let i=0;i<smallHeartGroups.length;i++){
    let group = smallHeartGroups[i];
    group.userData.angle += group.userData.speed;
    group.position.x = group.userData.radius * Math.cos(group.userData.angle);
    group.position.z = group.userData.radius * Math.sin(group.userData.angle);
  }

  let sArr = sparkGeo.attributes.position.array;
  for (let i=0;i<sparkCount;i++){
    sArr[i*3]   += sparkVel[i].x;
    sArr[i*3+1] += sparkVel[i].y;
    sArr[i*3+2] += sparkVel[i].z;
  }
  sparkGeo.attributes.position.needsUpdate = true;

  renderer.render(scene,camera);
}
animate();

window.addEventListener("resize",()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
