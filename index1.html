<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D Hearts with Pink Orbiting Hearts</title>
<style>
  body { margin: 0; background: black; overflow: hidden; }
  canvas { display: block; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script>
let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
let renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setPixelRatio(window.devicePixelRatio || 1);
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

function heart3D(numPoints, scale=1) {
  let points = [];
  while (points.length < numPoints) {
    let x = (Math.random()*2 - 1) * 1.5;
    let y = (Math.random()*2 - 1) * 1.5;
    let z = (Math.random()*2 - 1) * 1.5;
    let f = Math.pow(x*x + (9/4)*y*y + z*z - 1, 3) - x*x*z*z*z - (9/80)*y*y*z*z*z;
    if (f <= 0) points.push(x*20*scale, y*20*scale, z*20*scale);
  }
  return new Float32Array(points);
}

// === Trái tim đỏ ===
let heartGeo = new THREE.BufferGeometry();
heartGeo.setAttribute("position", new THREE.BufferAttribute(heart3D(30000, 1.3), 3));
let heartMat = new THREE.PointsMaterial({ size: 0.8, color: 0xff3366, transparent: true, opacity: 1.0, depthWrite: false });
let heart = new THREE.Points(heartGeo, heartMat);
let heartGroup = new THREE.Group();
heart.rotation.x = -Math.PI / 2;
heartGroup.add(heart);
scene.add(heartGroup);

// === Trái tim trắng giảm hạt ===
let whiteHeartGeo = new THREE.BufferGeometry();
whiteHeartGeo.setAttribute("position", new THREE.BufferAttribute(heart3D(15000, 2.5), 3));
let whiteHeartMat = new THREE.PointsMaterial({ size: 1.2, color: 0xffffff, transparent: true, opacity: 0.7, depthWrite: false });
let whiteHeart = new THREE.Points(whiteHeartGeo, whiteHeartMat);
let whiteHeartGroup = new THREE.Group();
whiteHeart.rotation.x = -Math.PI / 2;
whiteHeartGroup.add(whiteHeart);
scene.add(whiteHeartGroup);

// === Hạt phân tán nhiều màu ===
let particleCount = 4000;
let pGeo = new THREE.BufferGeometry();
let pPos = new Float32Array(particleCount*3);
let colors = new Float32Array(particleCount*3);
let velocities = [];
let brightness = [];
for (let i=0;i<particleCount;i++){
  pPos[i*3]=0; pPos[i*3+1]=0; pPos[i*3+2]=0;
  velocities.push({x:(Math.random()-0.5)*0.4, y:(Math.random()-0.5)*0.4, z:(Math.random()-0.5)*0.4});
  colors[i*3] = Math.random();
  colors[i*3+1] = Math.random();
  colors[i*3+2] = Math.random();
  brightness.push(Math.random() * Math.PI * 2);
}
pGeo.setAttribute("position", new THREE.BufferAttribute(pPos,3));
pGeo.setAttribute("color", new THREE.BufferAttribute(colors, 3));
let pMat = new THREE.PointsMaterial({ size:0.8, vertexColors:true, transparent:true, opacity:1.0 });
let particles = new THREE.Points(pGeo, pMat);
scene.add(particles);

// === Hạt nền màu lung linh ===
let backgroundSparkCount = 2000;
let bgSparkGeo = new THREE.BufferGeometry();
let bgSparkPos = new Float32Array(backgroundSparkCount*3);
let bgSparkVel = [];
let bgSparkColors = new Float32Array(backgroundSparkCount*3);
for (let i=0;i<backgroundSparkCount;i++){
  bgSparkPos[i*3] = (Math.random()-0.5)*600;
  bgSparkPos[i*3+1] = (Math.random()-0.5)*600;
  bgSparkPos[i*3+2] = (Math.random()-0.5)*600;
  let speed = Math.random()*0.6+0.2;
  let theta = Math.random()*Math.PI*2;
  let phi = Math.random()*Math.PI;
  bgSparkVel.push({ x: speed * Math.sin(phi) * Math.cos(theta), y: speed * Math.sin(phi) * Math.sin(theta), z: speed * Math.cos(phi) });
  bgSparkColors[i*3] = Math.random();
  bgSparkColors[i*3+1] = Math.random();
  bgSparkColors[i*3+2] = Math.random();
}
bgSparkGeo.setAttribute("position", new THREE.BufferAttribute(bgSparkPos,3));
bgSparkGeo.setAttribute("color", new THREE.BufferAttribute(bgSparkColors,3));
let bgSparkMat = new THREE.PointsMaterial({ size:1.2, vertexColors:true, transparent:true, opacity:1.0 });
let bgSparks = new THREE.Points(bgSparkGeo, bgSparkMat);
scene.add(bgSparks);

// === Tạo nhóm trái tim nhỏ quay quanh (màu hồng duy nhất) ===
let miniHearts = [];
let miniHeartCount = 8;
for (let i=0;i<miniHeartCount;i++){
  let miniGeo = new THREE.BufferGeometry();
  miniGeo.setAttribute("position", new THREE.BufferAttribute(heart3D(3000, 0.3), 3));
  let miniMat = new THREE.PointsMaterial({ size:0.3, color: 0xff3366, transparent:true, opacity:0.9 });
  let miniHeart = new THREE.Points(miniGeo, miniMat);
  let miniGroup = new THREE.Group();
  miniHeart.rotation.x = -Math.PI/2;
  miniGroup.add(miniHeart);
  miniGroup.userData = { radius: 60 + i*20, speed: 0.002 + i*0.0005, angle: Math.random()*Math.PI*2 };
  scene.add(miniGroup);
  miniHearts.push(miniGroup);
}

camera.position.z = 250;
camera.position.y = 0;

let time = 0;
function animate(){
  requestAnimationFrame(animate);
  time += 0.02;

  heartGroup.rotation.y -= 0.002;
  whiteHeart.material.opacity = 0.7 + 0.1 * Math.cos(time*2);

  let arr = pGeo.attributes.position.array;
  for (let i=0;i<particleCount;i++){
    arr[i*3]   += velocities[i].x;
    arr[i*3+1] += velocities[i].y;
    arr[i*3+2] += velocities[i].z;
    brightness[i] += 0.05;
  }
  let b = 1.0 + 0.3 * Math.sin(time*3);
  pMat.opacity = b;
  pGeo.attributes.position.needsUpdate = true;

  let bgArr = bgSparkGeo.attributes.position.array;
  for (let i=0;i<backgroundSparkCount;i++){
    bgArr[i*3]   += bgSparkVel[i].x;
    bgArr[i*3+1] += bgSparkVel[i].y;
    bgArr[i*3+2] += bgSparkVel[i].z;
    if (Math.abs(bgArr[i*3])>300 || Math.abs(bgArr[i*3+1])>300 || Math.abs(bgArr[i*3+2])>300){
      bgArr[i*3] = (Math.random()-0.5)*600;
      bgArr[i*3+1] = (Math.random()-0.5)*600;
      bgArr[i*3+2] = (Math.random()-0.5)*600;
    }
  }
  bgSparkGeo.attributes.position.needsUpdate = true;

  miniHearts.forEach(group => {
    group.userData.angle += group.userData.speed;
    group.position.x = Math.cos(group.userData.angle) * group.userData.radius;
    group.position.z = Math.sin(group.userData.angle) * group.userData.radius;
  });

  renderer.render(scene,camera);
}
animate();

window.addEventListener("resize",()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
