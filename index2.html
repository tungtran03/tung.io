<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D Heart Android Optimized - Smaller Particles</title>
<style>
  body { margin: 0; background: black; overflow: hidden; }
  canvas { display: block; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script>
let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
let renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

function heart3D(numPoints, scale=1) {
  let points = [];
  while (points.length < numPoints) {
    let x = (Math.random()*2 - 1) * 1.5;
    let y = (Math.random()*2 - 1) * 1.5;
    let z = (Math.random()*2 - 1) * 1.5;
    let f = Math.pow(x*x + (9/4)*y*y + z*z - 1, 3) - x*x*z*z*z - (9/80)*y*y*z*z*z;
    if (f <= 0) points.push(x*10*scale, y*10*scale, z*10*scale);
  }
  return new Float32Array(points);
}

// ===== Trái tim đỏ =====
let heartGeo = new THREE.BufferGeometry();
heartGeo.setAttribute("position", new THREE.BufferAttribute(heart3D(12000, 2), 3));
let heartMat = new THREE.PointsMaterial({
  size: 0.8, // giảm size hạt trái tim
  color: 0xff0033,
  transparent: true,
  opacity: 1.0
});
let heart = new THREE.Points(heartGeo, heartMat);
let heartGroup = new THREE.Group();
heart.rotation.x = -Math.PI / 2;
heartGroup.add(heart);
scene.add(heartGroup);

// ===== Hạt bắn ra =====
let particleCount = 400;
let pGeo = new THREE.BufferGeometry();
let pPos = new Float32Array(particleCount*3);
let colors = new Float32Array(particleCount*3);
let velocities = [];
let twinkleFactors = [];

function generateHeartParticle(i) {
  let points = heart3D(1, 1);
  pPos[i*3] = points[0];
  pPos[i*3+1] = points[1];
  pPos[i*3+2] = points[2];
  let dir = new THREE.Vector3(pPos[i*3], pPos[i*3+1], pPos[i*3+2]).normalize();
  velocities[i] = {
    x: dir.x * (Math.random()*0.5+0.2) + Math.random()*0.1,
    y: dir.y * (Math.random()*0.5+0.2) + Math.random()*0.1,
    z: dir.z * (Math.random()*0.5+0.2) + Math.random()*0.1
  };
  colors[i*3]   = Math.random();
  colors[i*3+1] = Math.random();
  colors[i*3+2] = Math.random();
  twinkleFactors[i] = Math.random() * 2;
}

for (let i=0;i<particleCount;i++) generateHeartParticle(i);

pGeo.setAttribute("position", new THREE.BufferAttribute(pPos,3));
pGeo.setAttribute("color", new THREE.BufferAttribute(colors, 3));
let pMat = new THREE.PointsMaterial({
  size: 0.4, // giảm size hạt bắn ra
  vertexColors: true,
  transparent: true,
  opacity: 1.0
});
let particles = new THREE.Points(pGeo, pMat);
scene.add(particles);

// ===== Trái tim nhỏ quay quanh màu hồng =====
let miniHearts = [];
let miniHeartCount = 4;
for (let i=0;i<miniHeartCount;i++){
  let miniGeo = new THREE.BufferGeometry();
  miniGeo.setAttribute("position", new THREE.BufferAttribute(heart3D(1500, 0.3), 3));
  let miniMat = new THREE.PointsMaterial({
    size: 0.3, // giảm size hạt trái tim nhỏ
    color: 0xff66cc,
    transparent:true,
    opacity:0.9
  });
  let miniHeart = new THREE.Points(miniGeo, miniMat);
  let miniGroup = new THREE.Group();
  miniHeart.rotation.x = -Math.PI/2;
  miniGroup.add(miniHeart);
  miniGroup.userData = { radius: 60 + i*20, speed: 0.001 + i*0.0005, angle: Math.random()*Math.PI*2 };
  scene.add(miniGroup);
  miniHearts.push(miniGroup);
}

// ===== Trái tim nhỏ bay tự do =====
let freeHearts = [];
let freeHeartCount = 20;
for (let i=0;i<freeHeartCount;i++){
  let freeGeo = new THREE.BufferGeometry();
  freeGeo.setAttribute("position", new THREE.BufferAttribute(heart3D(800, 0.2), 3));
  let freeMat = new THREE.PointsMaterial({
    size: 0.4, // giảm size hạt trái tim tự do
    color: 0xff66cc,
    transparent:true,
    opacity:0.9
  });
  let freeHeart = new THREE.Points(freeGeo, freeMat);
  let freeGroup = new THREE.Group();
  freeHeart.rotation.x = -Math.PI/2;
  freeGroup.add(freeHeart);
  freeGroup.userData = {
    pos: new THREE.Vector3((Math.random()-0.5)*300, (Math.random()-0.5)*300, (Math.random()-0.5)*300),
    velocity: new THREE.Vector3((Math.random()-0.5)*0.6, (Math.random()-0.5)*0.6, (Math.random()-0.5)*0.6),
    twinkle: Math.random()*2
  };
  freeHearts.push(freeGroup);
  scene.add(freeGroup);
}

camera.position.z = 200;
camera.position.y = 0;

let time = 0;
function animate(){
  requestAnimationFrame(animate);
  time += 0.02;
  heartGroup.rotation.y -= 0.005;

  let arr = pGeo.attributes.position.array;
  for (let i=0;i<particleCount;i++){
    arr[i*3]   += velocities[i].x;
    arr[i*3+1] += velocities[i].y;
    arr[i*3+2] += velocities[i].z;
    if (Math.abs(arr[i*3])>300 || Math.abs(arr[i*3+1])>300 || Math.abs(arr[i*3+2])>300){
      generateHeartParticle(i);
    }
  }
  pGeo.attributes.position.needsUpdate = true;
  pMat.opacity = 0.6 + 0.4 * Math.abs(Math.cos(time));

  miniHearts.forEach(group => {
    group.userData.angle += group.userData.speed;
    group.position.x = Math.cos(group.userData.angle) * group.userData.radius;
    group.position.z = Math.sin(group.userData.angle) * group.userData.radius;
  });

  freeHearts.forEach(group => {
    group.position.add(group.userData.velocity);
    group.userData.velocity.x += (Math.random()-0.5)*0.01;
    group.userData.velocity.y += (Math.random()-0.5)*0.01;
    group.userData.velocity.z += (Math.random()-0.5)*0.01;
    group.children[0].material.opacity = 0.6 + 0.4 * Math.abs(Math.cos(time*group.userData.twinkle));
    if (group.position.length() > 400) {
      group.position.set((Math.random()-0.5)*300, (Math.random()-0.5)*300, (Math.random()-0.5)*300);
    }
  });

  renderer.render(scene,camera);
}
animate();

window.addEventListener("resize",()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
